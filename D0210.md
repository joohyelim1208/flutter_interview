# 플러터 면접 스터디

## 숙련
- 0210 : Q. 플러터에서 위젯트리란 무엇인가요?
핵심: 정적/동적 위젯의 차이점을 이해, 생명주기와 앱의 성능 최적화를 고려해 효율적인 개발과 유지보수성 높이는 것이 중요
추가하기:

A. 플러터 위젯트리는 UI를 구성하는 모든 구성요소(버튼, 텍스트, 레이아웃 등)인 위젯들이 부모-자식 계층구조를 이루어 배치된 트리 형태의 구조입니다.
UI 화면구성 및 렌더링을 위한 기초데이터인 위젯트리를 프레임워크가 해석해서 실제 화면에 표시를 합니다.

작동원리는 플러터는 현재트리와 새로운 트리를 비교해서 어느 부분이 바뀌었는지 빠르게 찾아서 변경된 부분만 골라 화면에 다시 그립니다. 상태가 바뀔 때 마다 플러터가 트리를 비교하며 알아서 화면을 갱신해주기 때문에 개발자가 직접 UI변화 과정을 추적할 필요가 없는 장점이 있습니다.

상태변화에 따른 UI의 변화를 효율적으로 관리하기 위해서 위젯트리를 사용하며, 선언형 UI방식을 통해 개발자는 상태정의에만 집중할 수 있고, 프레임워크는 트리비교를 통해 변경된 부분만 최소한으로 렌더링해서 성능 최적화를 기대할 수 있습니다.

***
위젯트리의 핵심은 UI의 레이아웃과 부모와 자식관계를 명확히 정의하는 계층구조,
작은 위젯들을 조합해 복잡한 화면을 구성하는 컴포지션,
이 위젯트리들을 바탕으로 실제 화면에 그리기 위한 엘리먼트 트리와 렌더트리를 렌더링합니다.
statelessWidget에서는 불변인 위젯들의 정보일 뿐이라 화면에 직접 그려지는 객체는 아닌 정적인 구성,
statefulWidget에서의 동적 구성으로 이루어져 화면변화에 대응하며 이 구조를 효율적으로 관리하는 것이 앱 성능 최적화의 핵심입니다.

위젯트리는 크게 3종류로 나눌 수 있는데
Widget Tree: 설계도. 개발자가 선언한 위젯트리로 가볍다
Element Tree: 중간관리자. 위젯과 실제 화면을 연결하는 다리
Render Tree: 실제 회면에 렌더링되는 구조 입니다.(좌표, 크기 등 무거운 작업 수행)

위젯트리의 생명주기는
정적위젯인 스테이트리스위젯은 build()메서드가 한번만 호출되고, 상태가 변경되지 않기 때문에 다시 렌더링 되지 않습니다.
동적위젯인 스테이풀위젯은 setState()메서드를 호출하면 UI가 다시 빌드됩니다.
1. State객체를 생성하기
2. initState() - 위젯이 처음 생성될 때 호출
3. build() - UI를 그리는 메서드
4. setState() - 상태가 변경되면 build()가 다시 호출됨
5. dispose() - 위젯이 소멸될 때 호출됨

setState()에서 ListView.builder로 더 큰 가지를 만들 수 있다.

위젯트리가 커지면 렌더링 성능에 영향을 줄 수 있기 때문에 최적화를 합니다.
1. 위젯분리 - UI를 작은 위젯으로 나누어 재사용성을 높임. 작은 위젯(Text, Icon, Padding)을 조합해 더 큰 위젯(TodoTile)을 만들고 다시 더 큰 위젯(ListView)으로 조립할 수 있습니다.
2. const 사용 - 변경되지 않는 위젯에는 const키워드를 붙여서 불필요한 리빌드를 방지
3. Key 사용 - 리스트나 애니메이션이 있는 위젯에서 활용하면 효율적인 상태관리 가능
4. Provider 등 상태관리 도구 사용 - 상태가 여러 위젯에서 공유 될 경우 provider, Riverpod, Bloc 등 상태관리 도구를 사용해 성능향상이 가능하다. (setState()는 소규모일 때 적합함)

코드를 짤 때 구조를 예시로 들어보면?
***
추가질문.
1. 트리구조를 만드는 이유: 이진탐색 알고리즘 찾아보기.
: 정렬된 리스트에서 범위를 절반씩 좁혀가며 데이터를 찾는 방식.
사용이유: 시간복잡도. 선형탐색의 경우 for문으로 앞에서 하나씩 찾는 방식이면 데이터가 100만개일 경우 100만번 확인해야 되지만
이진탐색의 경우 데이터가 100만개여도 약 20번이면 원하는 값을 찾습니다. 
$$1,000,000 \rightarrow 500,000 \rightarrow 250,000 \dots \rightarrow 1$$
이진탐색의 한계
:반드시 데이터가 정렬되어 있어야 한다는 전제조건이 있습니다. 데이터를 정렬하는데 드는 비용이 추가로 발생하므로 탐색을 많이 반복해야 될 상황이 아니라면 단순 선형탐색이 더 빠를수도 있다.
-> 예시. Todo 앱에 검색기능을 넣는다면, TodoList를 날짜순이나 제목순으로 정렬해 둔 상태에서 이진탐색을 사용해 아주 빠른 검색시스템을 만들 수 있다!

2. 위젯트리의 3종류 외워두기!

3. 위젯트리와 다른 방식의 상태관리 방법은?
: 위젯트리를 따라서 데이터를 전달하는 방식은 트리가 깊어질 수록 데이터전달 릴레이(Prop Drilling)현상이 발생해 유지보수가 매우 힘들어진다.

트리 외부나 상단에서 상태를 효율적으로 관리하는 대표적인 3가지 방식

1. InheritedWidget 플러터 순정방식
: 위젯트리 상단에 대이터를 두고 그 아래 위젯 트리를 건너뛰고 직접 데이터에 접근할 수 있게 해주는 특별한 위젯
원리: buildContext를 이용해 트리를 거슬러 올라가 원하는 위젯을 찾는다
특징: 별도 라이브러리 설치가 필요없지만 코드가 복잡하고 반복되는 코드가 많다
예시: Theme.of(context), MediQuery.of(context) 방식

2. 라이브러리 사용. Provider / Riverpod (표준으로 사용되는 가장 대중적인 방식)
: InheritedWidget를 사용하기 쉽게 감싼 라이브러리. 
Provider: 위젯트리 상단에 changeNotifierProvider를 두고, 데이터가 변하면 해당 데이터를 구독중인 위젯들만 골라서 다시 그립니다.
Riverpod: Provider의 단점(buildContext 의존성 등)개선한 버전입니다. 컴파일 타임에 에러를 잡을 수 있고 위젯트리 밖에서도 상태를 관리할 수 있어 훨씬 강력합니다

3. BLoC (Business Logic Component)
: 이벤트(Stream)을 기반으로 상태를 관리하는 방식입니다. UI와 비즈니스 로직을 완전히 분리하고 싶을 때 사용하며, 규모가 큰 기업용 프로젝트에서 선호함
원리: 사용자의 동작이 들어오면 로직을 거쳐 새로운 상태(State)를 내보냄
장점: 테스트가 매우 용이하고 입출력이 명확하다.
단점: 학습곡선이 높고 코드가 다소 길다.

방식 | 키워드 | 추천 상황
SetState | 로컬 상태 | "단일 페이지, 간단한 UI 애니메이션"
Provider | 공유 상태 | "중소규모 앱, 입문자에게 적합"
Riverpod | 안정성/유연성 | 현대적인 플러터 앱 개발의 정석
BLoC | 스트림/엄격함 | "대규모 프로젝트, 복잡한 비즈니스 로직"