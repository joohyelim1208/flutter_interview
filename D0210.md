# 플러터 면접 스터디

## 
- 0210 : Q. 플러터에서 위젯트리란 무엇인가요?
핵심: 정적/동적 위젯의 차이점을 이해, 생명주기와 앱의 성능 최적화를 고려해 효율적인 개발과 유지보수성 높이는 것이 중요
추가하기:

A. 플러터 위젯트리는 UI를 구성하는 모든 구성요소(버튼, 텍스트, 레이아웃 등)인 위젯들이 부모-자식 계층구조를 이루어 배치된 트리 형태의 구조입니다.
UI 화면구성 및 렌더링을 위한 기초데이터인 위젯트리를 프레임워크가 해석해서 실제 화면에 표시를 합니다.

작동원리는 플러터는 현재트리와 새로운 트리를 비교해서 어느 부분이 바뀌었는지 빠르게 찾아서 변경된 부분만 골라 화면에 다시 그립니다. 상태가 바뀔 때 마다 플러터가 트리를 비교하며 알아서 화면을 갱신해주기 때문에 개발자가 직접 UI변화 과정을 추적할 필요가 없는 장점이 있습니다.

상태변화에 따른 UI의 변화를 효율적으로 관리하기 위해서 위젯트리를 사용하며, 선언형 UI방식을 통해 개발자는 상태정의에만 집중할 수 있고, 프레임워크는 트리비교를 통해 변경된 부분만 최소한으로 렌더링해서 성능 최적화를 기대할 수 있습니다.

***
위젯트리의 핵심은 UI의 레이아웃과 부모와 자식관계를 명확히 정의하는 계층구조,
작은 위젯들을 조합해 복잡한 화면을 구성하는 컴포지션,
이 위젯트리들을 바탕으로 실제 화면에 그리기 위한 엘리먼트 트리와 렌더트리를 렌더링합니다.
statelessWidget에서는 불변인 위젯들의 정보일 뿐이라 화면에 직접 그려지는 객체는 아닌 정적인 구성,
statefulWidget에서의 동적 구성으로 이루어져 화면변화에 대응하며 이 구조를 효율적으로 관리하는 것이 앱 성능 최적화의 핵심입니다.

위젯트리는 크게 3종류로 나눌 수 있는데
Widget Tree: 설계도. 개발자가 선언한 위젯트리로 가볍다
Element Tree: 중간관리자. 위젯과 실제 화면을 연결하는 다리
Render Tree: 실제 회면에 렌더링되는 구조 입니다.(좌표, 크기 등 무거운 작업 수행)

위젯트리의 생명주기는
정적위젯인 스테이트리스위젯은 build()메서드가 한번만 호출되고, 상태가 변경되지 않기 때문에 다시 렌더링 되지 않습니다.
동적위젯인 스테이풀위젯은 setState()메서드를 호출하면 UI가 다시 빌드됩니다.
1. State객체를 생성하기
2. initState() - 위젯이 처음 생성될 때 호출
3. build() - UI를 그리는 메서드
4. setState() - 상태가 변경되면 build()가 다시 호출됨
5. dispose() - 위젯이 소멸될 때 호출됨

setState()에서 ListView.builder로 더 큰 가지를 만들 수 있다.

위젯트리가 커지면 렌더링 성능에 영향을 줄 수 있기 때문에 최적화를 합니다.
1. 위젯분리 - UI를 작은 위젯으로 나누어 재사용성을 높임. 작은 위젯(Text, Icon, Padding)을 조합해 더 큰 위젯(TodoTile)을 만들고 다시 더 큰 위젯(ListView)으로 조립할 수 있습니다.
2. const 사용 - 변경되지 않는 위젯에는 const키워드를 붙여서 불필요한 리빌드를 방지
3. Key 사용 - 리스트나 애니메이션이 있는 위젯에서 활용하면 효율적인 상태관리 가능
4. Provider 등 상태관리 도구 사용 - 상태가 여러 위젯에서 공유 될 경우 provider, Riverpod, Bloc 등 상태관리 도구를 사용해 성능향상이 가능하다. (setState()는 소규모일 때 적합함)

코드를 짤 때 구조를 예시로 들어보면?
***
추가질문.
1. 트리구조를 만드는 이유: 이진탐색 알고리즘 찾아보기.

2. 위젯트리의 3종류 외워두기!