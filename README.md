# 플러터 면접 스터디

## 심화
- 0203 : Q. StatefulWidget 과 StatelessWidget 의 차이는 무엇인가요? 

A. 두 위젯의 차이는 변화하는 상태(state)를 관리할 수 있냐에 있습니다. 스테이트리스위젯은 부모위젯에서 새로운 데이터를 받지 않는 이상 갱신되지 않고, 고정된 데이터를 보여줄 때 사용하는 변하지 않는 위젯이고, 
스테이트풀위젯은 위젯과 상태클래스가 분리되어 있으며 동작하는 생명주기 동안 사용자의 상호작용이나 변화에 따라 바뀝니다.
state객체로 연결된 데이터를 추적하고, setState() 함수를 호출해서 UI화면을 동적으로 바꿀 수 있습니다.

가장 중요한 부분은 설계를 어떻게 하느냐에 달려있는데 스테이트리스위젯이 생명주기가 단순해 메모리 효율이 좋아 복잡도가 적어서 성능최적화를 위해 상태변화가 없는 부분은 스테이트리스위젯으로 분리해 설계하는 것이 좋다고 생각합니다.

그리고 가독성과 유지보수를 위해 provider나 piverpod같은 상태관리 라이브러리를 사용해 스테이트리스위젯 위주로 설계를 하려고 노력하고 있습니다.

***
추가질문.
스테이트풀위젯 생명주기 관련해서 설명을 정리해서 다시 해보기
어떤 과정으로 화면이 그려지는지
객체 생성부터 시작해서 스테이트리스위젯과 무엇이 다른지?

라이브러리도 가독성, 유지보수만 위해 쓰는건 아니고 상태관리 패키지로 설계했을 때와 그냥 스테이트풀위젯으로 설계했을 때의 차이점도 알아보기
***

## 숙련
- 0204 : Q. 위젯이 화면에 그려지기까지의 과정을 설명해보세요.

핵심: 불변하는 설계도(위젯)와 살아있는 상태(엘리먼트/스테이트)를 어떻게 효율적으로 연결하는가?
추가하기: 기존 작업했던 프로젝트에서 코드는 어떻게 사용했고 예시는?

A. 위젯이 화면에 그려지는 흐름에 대해서 '3가지 트리구조'를 중심으로 설명을 드리겠습니다.
그 과정은 크게 위젯트리 - 엘리먼트 트리 - 렌더 트리 라는 단계를 거칩니다.

첫번째로 위젯트리 구성은 개발자가 코드로 작성한 불변상태의 설계도 단계이기 때문에 
화면의 구성이 변경되면 아예 새로운 설계도를 다시 생성합니다.

두번째로 엘리먼트 트리는 위젯과 랜더 객체를 연결하는 중개 단계입니다. 
위젯트리와 달리 가변하며 위젯이 새로 생성이 되어도 기존 랜더 객체를 재사용할 수 있는 여부가 있기 때문에 성능 최적화의 역할을 합니다.

세번째로 렌더 트리는 실제 화면의 크기를 계산하고 그려내는 실행단계입니다.
이 단계에서 레이아웃은 부모에서는 제약조건을 아래로 내려보내고, 자식의 크기 정보는 위로 전달해서 결정이 됩니다,

트리가 3단계로 나뉘는 이유는 실제 화면을 계산하는 무거운 렌더객체를 매번 새로 만들지 않고,
중간에서 바뀐 가벼운 위젯 설계도만 기존 객체에 업데이트 해준다면 훨씬 효율적인 UI 갱신을 가능하게 해주기 때문입니다.

***
예상 추가질문.

1. 엘리먼트 트리가 재사용 여부를 판단하는 기준은?
엘리먼트 트리는 위젯의 런타임타입(클래스 타입이 같은지)과 키(위젯의 고유 식별키) 라는 두가지 정보를 비교해 재사용 여부를 결정하는데 이 두가지 모두 동일하다면 엘리먼트는 랜더객체를 삭제하지 않고 새 위젯의 정보로 업데이트만 진행합니다.

2. 스테이트리스위젯과 스테이트풀위젯의 엘리먼트 트리 관점에서의 차이점은?
각 생성하는 엘리먼트 종류가 다릅니다.
스테이트리스위젯은 단순히 정보를 전달하는 스테이트리스엘리먼트를 생성하고, 별도의 메모리 저장이 없기 때문에 위젯트리에서 정보가 바뀌면 새 위젯을 받아 업데이트 합니다.
스테이트풀위젯은 스테이트풀엘리먼트를 생성합니다. 별도의 스테이트 객체를 참조하며, 셋스테이트를 호출할 때 스테이트 객체에 변경되었음을 알리고,
다음 프레임에서 이 엘리먼트가 자신의 빌드 메서드를 다시 실행해서 하위 위젯을 갱신하게 됩니다.
위젯은 바뀌어도 스테이트 객체와 엘리먼트는 메모리에 유지되어서 연속적인 상태를 가질 수 있습니다.
***

## 
- 0205 : Q.
핵심:
추가하기:

A.