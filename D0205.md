# 플러터 면접 스터디

## OOP
- 0205 : Q. 객체지향이란 무엇인지 설명하세요.
핵심: 가치(왜 사용하는가?), 방법(4대 핵심 원칙) 
추가하기:

A. 객체지향 프로그래밍(OPP)이란 명령어의 나열이 아니라 데이터와 메서드를 객체라는 하나의 집합으로 보고, 이 객체들이 서로 상호작용 하도록 설계하는 것입니다. 
프로그램을 묶음 단위로 쪼개서 가져다쓰기 편하게 만든 것인데 객체지향의 목적은 코드의 재사용성을 높이고, 유지보수와 확장성에 용이하게 하기 위함입니다. 
장점은 전체 프로젝트를 한번에 수정할 필요 없이 기능을 하는 부분들만 수정 할 수 있기 때문에 복잡한 시스템도 구조적으로도 파악을 하기 좋아지게 됩니다.

객체지향은 4대 핵심 원칙을 따르고 있는데 캡슐화, 상속, 추상화, 다형성 원칙이 있으며 각 원칙의 이점은
첫번째 '캡슐화'란? (_ 언더바 사용)
데이터와 기능을 감싸서 외부에서 직접 접근하지 못하게 해서 데이터를 보호하는 것입니다.
예시로 리모컨이 있다면 캡슐화는 리모컨 내부의 회로와 시스템을 프레임으로 감싼 것이고, 사용자는 리모컨의 버튼만 누르면 쉽게 조작할 수 있지만 리모컨 내부를 직접 조작할 수는 없습니다.

두번째 '상속'이란? (extend 사용)
부모클래스의 기능을 자식클래스가 물려받는 것으로 코드의 중복을 제거하고 재사용성을 극대화 합니다.

세번째 '추상화'란? (복잡한 로직은 숨기고 인터페이스만 노출)
복잡한 내부 구현은 숨기고 공통의 핵심 특징만 단순화하는 것입니다. 사용자는 인터페이스만 사용할 뿐 세부사항을 몰라도 기능사용에 아무런 문제가 없습니다.
운전에 비유한다면 사용자는 자동차의 페달을 밟아서 동작을 하면 된다는 것만 알면 되고, 엔진이 어떤식으로 연료를 소모하고 기어가 맞물리는지는 몰라도 운전에는 아무런 문제가 없습니다.

네번째로 '다형성'이란? (같은 이름의 메서드가 상황에 따라 다르게 동작하는 것)
하나의 인터페이스가 상황에 따라 여러 기능으로 동작하는 것으로 코드의 유연성을 높여줍니다.
부모 타입이 자식 객체를 참조해 새로운 기능을 추가할 때 기존 코드를 수정할 필요가 줄어듭니다.

여기서 캡슐화와 추상화의 개념이 비슷해 보이지만 다른점은 목적과 방향성에 있습니다.
캡슐화는 데이터를 숨겨서 보호를 하기 위한 것이고, 추상화는 단순화를 위한 것으로 사용자에게 무엇을 보여줄지를 고민합니다.

객체지향 프로그래밍은 현장에서는 여러 개발자들이 대규모 프로젝트를 작업할 때 객체 단위로 나누어 분업하기 편하도록 해주기에 꼭 필요한 프로그래밍 입니다.

***
추가질문.
1. 객체지향의 특징은 무엇이 있나요? 4대 핵심 원칙

2. opp란?
데이터(상태)와 기능(동작)을 가진 객체라는 기본단위로 나누고, 이 객체들 간의 상호작용을 통해 프로그램을 구성하는 방식입니다.
opp를 이루는 세가지 구성요소는?
객체를 만드는 설계도인 클래스, 설계도를 바탕으로 실제 메모리에 만들어진 객체와 인스턴스, 객체가 행동하도록 하는 함수인 메서드로 이루어져 있습니다.

3. SOLID 원칙은 무엇인가요?
유지보수가 쉽고, 확장이 유연한 소프트웨어를 만들기 위한 5가지 핵심 원칙의 앞 글자를 딴 것입니다.
S : 단일책임 원칙. 하나의 클래스는 단 하나의 책임만 가집니다. 너무 여러 기능을 한번에 가지면 오류가 날 가능성이 큽니다.
O : 개방-폐쇄 원칙. 확장에는 열려있고 수정에는 닫혀있습니다. 기존코드를 수정하지 않고도 기능 확장 가능해야 합니다.
L : 리스코프 치환 원칙. 자식클래스는 부모클래스를 대체할 수 있어야 합니다. 자식이 부모의 기능을 억지로 바꾸거나 망가트리면 안됩니다.
I : 인터페이스 분리 원칙. 사용하지 않는 메서드에 강제로 의존하도록 하면 안됩니다. 여러개의 구체적인 인터페이스로 나눠서 사용합니다.
D : 의존 역전 원칙. 구체적인 것 보다는 추상적인 것 인터페이스와 추상클래스에 에 의존해야 변화에 유연합니다. 그래야 DB가 바뀌어도 메인은 안전합니다.

4. 절차지향적 프로그래밍과의 차이점?
상반되는 것에 대한 정리 해보기
단순히 외우는 것이 아니라 예제 코드를 이용해서 전체적인 흐름을 설명하고 이해한 부분을 설명하기 !!


절차지향과 비교하는건 쉬운 코드다. C언어를 읽을 수 있을 정도면 됨!!
다른 언어들 자체가 어렵다기 보다는 환경이 달라졌을 때 어려운 점은 그쪽 생태계가 달라서 의존성, 빌드하는 방법 등 이런게 문제가 되는 것 